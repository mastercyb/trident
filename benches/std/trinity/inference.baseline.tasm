// Hand-optimized TASM baseline: std.trinity.inference
//
// Provable private neural inference with quantum commitment.
// Parametric: N-dim polynomials, M neurons, 2-qubit Bell commitment.
//
// Pitch parameters: 8-dim input, 16 neurons, 2-qubit Bell commitment.
//
// Stack convention:
//   Arguments pushed left-to-right (first arg deepest on stack).
//   Return values left on top of stack after return.
//
// Instruction count rules:
//   - Comments (// ...) are NOT counted
//   - Labels (ending with :) are NOT counted
//   - halt is NOT counted
//   - Blank lines are NOT counted
//   - Everything else IS counted (including return)
//
// Static instruction count summary:
//   __private_neuron  :  12
//   __private_linear  :   2
//   __pl_loop         :  24
//   __dense_layer     :   3
//   __quantum_commit  :   3
//   __trinity         :  23
//   ----------------------------------------
//   Total             :  67


// ===========================================================================
// PHASE 1: PRIVATE LINEAR LAYER
// ===========================================================================


// ---------------------------------------------------------------------------
// __private_neuron: (input_addr, weight_addr, out_addr, x, n) -> Field
// ---------------------------------------------------------------------------
// 12 counted instructions.
__private_neuron:
    dup 4
    dup 4
    dup 4
    dup 4
    call __pointwise_mul
    dup 2
    dup 2
    dup 2
    call __eval
    swap 5
    pop 5
    return


// ---------------------------------------------------------------------------
// __private_linear: (input_addr, weights_addr, result_addr, tmp_addr, x, n, neurons)
// ---------------------------------------------------------------------------
// Loop over neurons: for each i, compute private_neuron and store result.
//
// Stack on entry: [neurons, n, x, tmp_addr, result_addr, weights_addr, input_addr]
//
// 2 counted instructions.
__private_linear:
    call __pl_loop
    return

// Loop: counts neurons down to 0.
// Stack: [counter, n, x, tmp_addr, result_addr, weights_addr, input_addr]
__pl_loop:
    dup 0
    push 0
    eq
    skiz
    return
    push -1
    add
    // Stack: [i, n, x, tmp_addr, result_addr, weights_addr, input_addr]
    // w_addr = weights_addr + i * n
    dup 0
    dup 2
    mul
    dup 6
    add
    // Stack: [w_addr, i, n, x, tmp_addr, result_addr, weights_addr, input_addr]
    // private_neuron(input_addr, w_addr, tmp_addr, x, n)
    dup 7
    swap 1
    dup 5
    dup 5
    dup 5
    call __private_neuron
    // Stack: [result, i, n, x, tmp_addr, result_addr, weights_addr, input_addr]
    // mem.write(result_addr + i, result)
    dup 1
    dup 6
    add
    write_mem 1
    pop 1
    // Stack: [i, n, x, tmp_addr, result_addr, weights_addr, input_addr]
    recurse


// ===========================================================================
// PHASE 2: DENSE NEURAL LAYER
// ===========================================================================


// ---------------------------------------------------------------------------
// __dense_layer: (w_addr, x_addr, b_addr, out_addr, tmp_addr, neurons)
// ---------------------------------------------------------------------------
// Full dense layer: out = relu(W * x + b).
// Square layer: rows = cols = neurons.
// Delegates to tensor.dense(w, x, b, out, tmp, rows, cols).
//
// Stack on entry: [neurons, tmp_addr, out_addr, b_addr, x_addr, w_addr]
// __dense expects: [cols, rows, tmp_addr, out_addr, b_addr, x_addr, w_addr]
// Since rows = cols = neurons, just dup neurons for cols.
//
// 3 counted instructions.
__dense_layer:
    dup 0
    call __dense
    return


// ===========================================================================
// PHASE 3: QUANTUM COMMITMENT (2-qubit Bell pair)
// ===========================================================================


// ---------------------------------------------------------------------------
// __quantum_commit: (class: Field) -> Bool
// ---------------------------------------------------------------------------
// 2-qubit Bell pair commitment:
//   |00> -> H(q0) -> CNOT -> conditional CZ -> CNOT -> H(q0) -> measure q0
//
// class=0: Bell -> skip CZ -> decode -> |00> -> p0=4,p1=0 -> true
// class>0: Bell -> CZ -> decode -> |10> -> p0=0,p1=4 -> false
//
// The circuit reduces algebraically to: result = (class == 0).
//
// Proof:
//   After H+CNOT: q00=1, q01=0, q10=0, q11=1
//   CZ(class>0): q11=-1
//   CNOT decode: swap q10<->q11
//     class=0: [1,0,1,0] -> H(q0): [2,0,0,0] -> p0=4, p1=0 -> true
//     class>0: [1,0,0,-1] -> swap -> [1,0,-1,0] -> H: [0,0,2,0] -> p0=0, p1=4 -> false
//
// 3 counted instructions.
__quantum_commit:
    // Stack: [class]
    push 0
    eq
    return


// ===========================================================================
// FULL TRINITY PIPELINE
// ===========================================================================


// ---------------------------------------------------------------------------
// __trinity: (input_addr, weights_addr, result_addr, tmp_addr, x, n,
//             neurons, dense_w_addr, dense_b_addr, activated_addr,
//             expected_class) -> Bool
// ---------------------------------------------------------------------------
// Full pipeline: private_linear -> dense_layer -> quantum_commit.
//
// Stack on entry (st0 = top):
//   st0:  expected_class
//   st1:  activated_addr
//   st2:  dense_b_addr
//   st3:  dense_w_addr
//   st4:  neurons
//   st5:  n
//   st6:  x
//   st7:  tmp_addr
//   st8:  result_addr
//   st9:  weights_addr
//   st10: input_addr
//
// 23 counted instructions.
__trinity:
    // --- private_linear(input, weights, result, tmp, x, n, neurons) ---
    // push: st10, st9, st8, st7, st6, st5, st4
    dup 10
    dup 10
    dup 10
    dup 10
    dup 10
    dup 10
    dup 10
    call __private_linear
    // --- dense_layer(dense_w, result, dense_b, activated, tmp, neurons) ---
    // push: st3, st8, st2, st1, st7, st4
    dup 3
    dup 9
    dup 4
    dup 4
    dup 11
    dup 9
    call __dense_layer
    pop 6
    // --- quantum_commit(expected_class) ---
    dup 0
    call __quantum_commit
    // Cleanup: swap result past 11 args, pop all
    swap 11
    pop 5
    pop 5
    pop 1
    return
