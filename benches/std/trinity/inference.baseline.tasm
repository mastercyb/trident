// Hand-optimized TASM baseline: std.trinity.inference
//
// Provable private neural inference with quantum commitment.
// Real LWE encryption over Goldilocks, dense neural layer,
// 2-qubit Bell pair commitment.
//
// Pitch parameters: LWE dim 8, 8 inputs, 16 neurons, Bell commitment.
//
// Stack convention:
//   Arguments pushed left-to-right (first arg deepest on stack).
//   Return values left on top of stack after return.
//
// Instruction count rules:
//   - Comments (// ...) are NOT counted
//   - Labels (ending with :) are NOT counted
//   - halt is NOT counted
//   - Blank lines are NOT counted
//   - Everything else IS counted (including return)
//
// Static instruction count summary:
//   __decrypt_loop    :  24
//   __dense_layer     :   3
//   __quantum_commit  :   3
//   __trinity         :  37
//   ----------------------------------------
//   Total             :  67


// ===========================================================================
// PHASE 1b: DECRYPT OUTPUTS (loop)
// ===========================================================================


// Decrypt loop: counts neurons down to 0.
// Stack: [counter, lwe_n, delta, result_addr, s_addr, ct_out_addr]
__decrypt_loop:
    dup 0
    push 0
    eq
    skiz
    return
    push -1
    add
    // Stack: [i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    // ct_addr = ct_out_addr + i * (lwe_n + 1)
    dup 0
    dup 2
    push 1
    add
    mul
    dup 6
    add
    // Stack: [ct_addr, i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    // lwe.decrypt(ct_addr, s_addr, delta, lwe_n) -> m
    dup 5
    dup 4
    dup 4
    call __lwe_decrypt
    // Stack: [m, i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    // mem.write(result_addr + i, m)
    dup 1
    dup 5
    add
    write_mem 1
    pop 1
    // Stack: [i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    recurse


// ===========================================================================
// PHASE 2: DENSE NEURAL LAYER
// ===========================================================================


// ---------------------------------------------------------------------------
// __dense_layer: (w_addr, x_addr, b_addr, out_addr, tmp_addr, neurons)
// ---------------------------------------------------------------------------
// Square dense layer: rows = cols = neurons.
//
// 3 counted instructions.
__dense_layer:
    dup 0
    call __dense
    return


// ===========================================================================
// PHASE 3: QUANTUM COMMITMENT (2-qubit Bell pair)
// ===========================================================================


// ---------------------------------------------------------------------------
// __quantum_commit: (class: Field) -> Bool
// ---------------------------------------------------------------------------
// 2-qubit Bell pair reduces to: result = (class == 0).
//
// 3 counted instructions.
__quantum_commit:
    push 0
    eq
    return


// ===========================================================================
// FULL TRINITY PIPELINE
// ===========================================================================


// ---------------------------------------------------------------------------
// __trinity: (cts_addr, s_addr, w_priv_addr, ct_out_addr, tmp_addr,
//             result_addr, delta, lwe_n, input_dim, neurons,
//             dense_w_addr, dense_b_addr, activated_addr,
//             expected_class) -> Bool
// ---------------------------------------------------------------------------
// Full pipeline:
//   1. lwe.private_linear (external)
//   2. decrypt_outputs (inline loop)
//   3. dense_layer
//   4. argmax + assert (data dependency: AI -> Quantum)
//   5. quantum_commit
//
// Stack on entry (st0 = top, 14 args):
//   st0:  expected_class
//   st1:  activated_addr
//   st2:  dense_b_addr
//   st3:  dense_w_addr
//   st4:  neurons
//   st5:  input_dim
//   st6:  lwe_n
//   st7:  delta
//   st8:  result_addr
//   st9:  tmp_addr
//   st10: ct_out_addr
//   st11: w_priv_addr
//   st12: s_addr
//   st13: cts_addr
//
// 37 counted instructions.
__trinity:
    // --- Phase 1: lwe.private_linear(cts, w_priv, ct_out, tmp, lwe_n, input_dim, neurons) ---
    dup 13
    dup 12
    dup 12
    dup 12
    dup 10
    dup 10
    dup 10
    call __lwe_private_linear
    // --- Phase 1b: decrypt_outputs(ct_out, s, result, delta, lwe_n, neurons) ---
    // Push args for __decrypt_loop: [neurons, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    dup 4
    dup 7
    dup 9
    dup 11
    dup 15
    dup 14
    call __decrypt_loop
    pop 6
    // --- Phase 2: dense_layer(dense_w, result, dense_b, activated, tmp, neurons) ---
    dup 3
    dup 9
    dup 4
    dup 4
    dup 13
    dup 9
    call __dense_layer
    pop 6
    // --- argmax(activated_addr, neurons) + assert class == expected ---
    // Stack: [expected_class, activated_addr, dense_b, dense_w, neurons, ...]
    dup 1
    dup 5
    call __tensor_argmax
    // Stack: [class, expected_class, activated_addr, ...]
    dup 0
    dup 2
    eq
    assert
    // --- Phase 3: quantum_commit(class) ---
    call __quantum_commit
    // Cleanup: swap result past 14 args, pop all
    swap 14
    pop 5
    pop 5
    pop 4
    return
