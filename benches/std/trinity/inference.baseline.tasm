// Hand-optimized TASM baseline: std.trinity.inference
//
// Provable private neural inference with quantum commitment.
// Real LWE encryption over Goldilocks, lookup-table ReLU activation,
// 2-qubit Bell pair commitment.
//
// The ReLU lookup table is the Rosetta Stone primitive: the same
// table serves as NN activation and FHE PBS test polynomial.
//
// Pitch parameters: LWE dim 8, 8 inputs, 16 neurons, Bell commitment.
//
// Stack convention:
//   Arguments pushed left-to-right (first arg deepest on stack).
//   Return values left on top of stack after return.
//
// Instruction count rules:
//   - Comments (// ...) are NOT counted
//   - Labels (ending with :) are NOT counted
//   - halt is NOT counted
//   - Blank lines are NOT counted
//   - Everything else IS counted (including return)
//
// Static instruction count summary:
//   __decrypt_loop    :  24
//   __dense_layer     :  17
//   __quantum_commit  :   3
//   __trinity         :  38
//   ----------------------------------------
//   Total             :  82


// ===========================================================================
// PHASE 1b: DECRYPT OUTPUTS (loop)
// ===========================================================================


// Decrypt loop: counts neurons down to 0.
// Stack: [counter, lwe_n, delta, result_addr, s_addr, ct_out_addr]
__decrypt_loop:
    dup 0
    push 0
    eq
    skiz
    return
    push -1
    add
    // Stack: [i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    // ct_addr = ct_out_addr + i * (lwe_n + 1)
    dup 0
    dup 2
    push 1
    add
    mul
    dup 6
    add
    // Stack: [ct_addr, i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    // lwe.decrypt(ct_addr, s_addr, delta, lwe_n) -> m
    dup 5
    dup 4
    dup 4
    call __lwe_decrypt
    // Stack: [m, i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    // mem.write(result_addr + i, m)
    dup 1
    dup 5
    add
    write_mem 1
    pop 1
    // Stack: [i, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    recurse


// ===========================================================================
// PHASE 2: DENSE NEURAL LAYER (with lookup-table activation)
// ===========================================================================


// ---------------------------------------------------------------------------
// __dense_layer: (w_addr, x_addr, b_addr, out_addr, tmp_addr, lut_addr, neurons)
// ---------------------------------------------------------------------------
// Dense layer: out = lut_relu(W * x + b).
// Delegates to three external calls:
//   1. matvec(w, x, tmp, neurons, neurons)
//   2. bias_add(tmp, b, out, neurons)
//   3. lut.apply(lut, out, out, neurons)
// The lookup table is the Rosetta Stone primitive.
//
// Stack: [w, x, b, out, tmp, lut, neurons]
//   st0: w_addr      st3: out_addr     st6: neurons
//   st1: x_addr      st4: tmp_addr
//   st2: b_addr      st5: lut_addr
//
// 17 counted instructions.
__dense_layer:
    // --- matvec(w, x, tmp, neurons, neurons) ---
    // Need on stack: [w, x, tmp, neurons, neurons] (first arg deepest)
    dup 6
    dup 7
    dup 7
    dup 4
    dup 4
    call __tensor_matvec
    // --- bias_add(tmp, b, out, neurons) ---
    // Need on stack: [tmp, b, out, neurons]
    dup 6
    dup 4
    dup 5
    dup 7
    call __tensor_bias_add
    // --- lut.apply(lut, out, out, neurons) ---
    // Need on stack: [lut, out, out, neurons]
    dup 6
    dup 4
    dup 5
    dup 8
    call __lut_apply
    return


// ===========================================================================
// PHASE 3: QUANTUM COMMITMENT (2-qubit Bell pair)
// ===========================================================================


// ---------------------------------------------------------------------------
// __quantum_commit: (class: Field) -> Bool
// ---------------------------------------------------------------------------
// 2-qubit Bell pair reduces to: result = (class == 0).
//
// 3 counted instructions.
__quantum_commit:
    push 0
    eq
    return


// ===========================================================================
// FULL TRINITY PIPELINE
// ===========================================================================


// ---------------------------------------------------------------------------
// __trinity: (cts_addr, s_addr, w_priv_addr, ct_out_addr, tmp_addr,
//             result_addr, delta, lwe_n, input_dim, neurons,
//             dense_w_addr, dense_b_addr, activated_addr,
//             lut_addr, expected_class) -> Bool
// ---------------------------------------------------------------------------
// Full pipeline:
//   1. lwe.private_linear (external)
//   2. decrypt_outputs (inline loop)
//   3. dense_layer with lookup-table ReLU (Rosetta Stone)
//   4. argmax + assert (data dependency: AI -> Quantum)
//   5. quantum_commit
//
// Stack on entry (st0 = top, 15 args):
//   st0:  expected_class
//   st1:  lut_addr
//   st2:  activated_addr
//   st3:  dense_b_addr
//   st4:  dense_w_addr
//   st5:  neurons
//   st6:  input_dim
//   st7:  lwe_n
//   st8:  delta
//   st9:  result_addr
//   st10: tmp_addr
//   st11: ct_out_addr
//   st12: w_priv_addr
//   st13: s_addr
//   st14: cts_addr
//
// 38 counted instructions.
__trinity:
    // --- Phase 1: lwe.private_linear(cts, w_priv, ct_out, tmp, lwe_n, input_dim, neurons) ---
    dup 14
    dup 13
    dup 13
    dup 13
    dup 11
    dup 11
    dup 11
    call __lwe_private_linear
    // --- Phase 1b: decrypt_outputs ---
    // Push args for __decrypt_loop: [neurons, lwe_n, delta, result_addr, s_addr, ct_out_addr]
    dup 5
    dup 8
    dup 10
    dup 12
    dup 16
    dup 15
    call __decrypt_loop
    pop 6
    // --- Phase 2: dense_layer(dense_w, result, dense_b, activated, tmp, lut, neurons) ---
    dup 4
    dup 10
    dup 5
    dup 5
    dup 14
    dup 5
    dup 11
    call __dense_layer
    pop 7
    // --- argmax(activated_addr, neurons) + assert class == expected ---
    // Stack: [expected_class, lut_addr, activated_addr, dense_b, dense_w, neurons, ...]
    dup 2
    dup 6
    call __tensor_argmax
    // Stack: [class, expected_class, lut_addr, activated_addr, ...]
    dup 0
    dup 2
    eq
    assert
    // --- Phase 3: quantum_commit(class) ---
    call __quantum_commit
    // Cleanup: swap result past 15 args, pop all
    swap 15
    pop 5
    pop 5
    pop 5
    return
