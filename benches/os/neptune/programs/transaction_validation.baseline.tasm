// Hand-optimized TASM baseline: os.neptune.programs.transaction_validation
// Full Neptune transaction validation program.
//
// Steps:
//   1. Read kernel_hash from public input
//   2. Read num_inputs, num_type_scripts
//   3. Authenticate kernel fields (fee, timestamp, mutator_set) via Merkle
//   4. Verify lock script proofs (loop)
//   5. Verify type script proofs (loop)
//   6. Output validated kernel_hash + fee
//
// Shared subroutines: __authenticate_leaf3 for Merkle auth,
// __verify_inner_proof for recursive proof verification.

__main:
    // Step 1: Read kernel_hash (5 fields)
    read_io 5
    // Step 2: Read num_inputs, num_type_scripts
    read_io 1
    read_io 1
    // Stack: num_ts num_inputs k4 k3 k2 k1 k0
    // Step 3: Authenticate fee (leaf 3)
    // Save counts, duplicate kernel_hash for Merkle auth
    swap 6
    swap 5
    // Stack: ... kernel_hash num_inputs num_ts
    // We need kernel_hash accessible for multiple authentications.
    // Store in memory for repeated access.
    // mem[0..4] = kernel_hash
    dup 4
    push 0
    write_mem 1
    pop 1
    dup 4
    push 1
    write_mem 1
    pop 1
    dup 4
    push 2
    write_mem 1
    pop 1
    dup 4
    push 3
    write_mem 1
    pop 1
    dup 4
    push 4
    write_mem 1
    pop 1
    // Authenticate fee leaf (index 3)
    push 3
    dup 5
    dup 5
    dup 5
    dup 5
    dup 5
    call __authenticate_leaf3
    // Stack: fee_leaf(5) ... kernel_hash num_inputs num_ts
    // Extract fee amount (first field of leaf)
    swap 4
    pop 1
    swap 3
    pop 1
    swap 2
    pop 1
    swap 1
    pop 1
    // Stack: fee_amount ... kernel_hash num_inputs num_ts
    // Assert fee non-negative
    dup 0
    split
    push 0
    eq
    assert
    pop 1
    // Save fee in memory for final output
    push 10
    write_mem 1
    pop 1
    // Authenticate timestamp leaf (index 5)
    push 0
    read_mem 1
    pop 1
    push 1
    read_mem 1
    pop 1
    push 2
    read_mem 1
    pop 1
    push 3
    read_mem 1
    pop 1
    push 4
    read_mem 1
    pop 1
    push 5
    swap 5
    swap 4
    swap 3
    swap 2
    swap 1
    call __authenticate_leaf3
    pop 5
    // Authenticate mutator_set leaf (index 6)
    push 0
    read_mem 1
    pop 1
    push 1
    read_mem 1
    pop 1
    push 2
    read_mem 1
    pop 1
    push 3
    read_mem 1
    pop 1
    push 4
    read_mem 1
    pop 1
    push 6
    swap 5
    swap 4
    swap 3
    swap 2
    swap 1
    call __authenticate_leaf3
    pop 5
    // Stack: ... kernel_hash num_inputs num_ts
    // Step 4: Verify lock script proofs
    // Stack manipulation: get num_inputs to top
    swap 1
    push 4
    swap 1
    // Stack: ... num_ts 4 num_inputs
    call __verify_proofs_loop
    pop 1
    pop 1
    // Step 5: Verify type script proofs
    push 4
    swap 1
    // Stack: ... 4 num_ts
    call __verify_proofs_loop
    pop 1
    pop 1
    // Step 6: Output kernel_hash
    write_io 5
    // Output fee
    push 10
    read_mem 1
    pop 1
    write_io 1
    halt

// __authenticate_leaf3: Merkle auth at depth 3
// Stack entry: idx d4 d3 d2 d1 d0
// Divines 3 siblings, performs 3 merkle_step operations.
__authenticate_leaf3:
    divine 5
    merkle_step
    divine 5
    merkle_step
    divine 5
    merkle_step
    swap 5
    pop 1
    return

// __verify_proofs_loop: verify N inner proofs
// Stack entry: num_fri_rounds count
__verify_proofs_loop:
    dup 0
    push 0
    eq
    skiz
    return
    push -1
    add
    dup 1
    call __verify_inner_proof_short
    recurse

// __verify_inner_proof_short: minimal inner proof verification
// Stack: num_fri_rounds
__verify_inner_proof_short:
    read_io 5
    read_io 1
    read_io 1
    swap 6
    pop 1
    swap 5
    pop 1
    push 0
    push 0
    push 0
    push 0
    push 0
    push 0
    push 0
    push 0
    push 0
    push 0
    hash
    hash
    divine 5
    pop 5
    pop 5
    divine 5
    pop 5
    divine 1
    divine 1
    divine 1
    pop 3
    pop 1
    write_io 5
    return
