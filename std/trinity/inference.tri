module std.trinity.inference

// Provable private neural inference with quantum commitment.
//
// Three revolutions, one program:
//   Phase 1 — Privacy: FHE-style linear layer (polynomial arithmetic)
//   Phase 2 — Neural:  ReLU activation + bias
//   Phase 3 — Quantum: Deutsch oracle commitment circuit
//
// The STARK proof covers everything. No other system on earth does this.
//
// Pitch parameters:
//   16-dim encrypted input, 16-neuron hidden layer, Deutsch oracle commitment.
//   ~11K dynamic ops, ~3s prove, ~5MB proof.
use vm.core.field

use vm.core.convert

use vm.io.mem

use std.nn.tensor

use std.private.poly

use std.quantum.gates

// ---------------------------------------------------------------------------
// Phase 1: Private linear layer via polynomial arithmetic
// ---------------------------------------------------------------------------
// One encrypted neuron: pointwise-mul input with weight polynomial,
// then evaluate at point x to extract the scalar dot product.
pub fn private_neuron(
    input_addr: Field,
    weight_addr: Field,
    out_addr: Field,
    x: Field,
    n: Field
) -> Field {
    poly.pointwise_mul(input_addr, weight_addr, out_addr, n)
    poly.eval(out_addr, x, n)
}

// Full private linear layer: neurons neurons, each a polynomial product.
// weights laid out contiguously: w[i] starts at weights_addr + i * n.
pub fn private_linear(
    input_addr: Field,
    weights_addr: Field,
    result_addr: Field,
    tmp_addr: Field,
    x: Field,
    n: Field,
    neurons: Field
) {
    for i in 0..neurons bounded 4096 {
        let idx: Field = convert.as_field(i)
        let w_addr: Field = weights_addr + idx * n
        let r: Field = private_neuron(input_addr, w_addr, tmp_addr, x, n)
        mem.write(result_addr + idx, r)
    }
}

// ---------------------------------------------------------------------------
// Phase 2: Neural activation
// ---------------------------------------------------------------------------
// Standard dense layer post-processing: bias add then ReLU.
pub fn activate(result_addr: Field, bias_addr: Field, out_addr: Field, neurons: Field) {
    tensor.bias_add(result_addr, bias_addr, out_addr, neurons)
    tensor.relu_layer(out_addr, out_addr, neurons)
}

// ---------------------------------------------------------------------------
// Phase 3: Quantum verification commitment (Deutsch oracle)
// ---------------------------------------------------------------------------
// Deutsch's algorithm — the first quantum speedup ever discovered.
// Single-qubit oracle commitment:
//   |0> -> H -> conditional Z -> H -> measure
//
// class=0 (constant oracle): H|0>=|+>, skip Z, H|+>=|0> -> measure true
// class>0 (balanced oracle):  H|0>=|+>, Z|+>=|->, H|->=|1> -> measure false
//
// The STARK proof covers the full circuit trace.
pub fn quantum_commit(class: Field) -> Bool {
    let q: gates.Qubit = gates.init_zero()
    let qh: gates.Qubit = gates.hadamard(q)
    let mut qz: gates.Qubit = qh
    if class {
        qz = gates.pauliz(qh)
    }
    let qf: gates.Qubit = gates.hadamard(qz)
    gates.measure_deterministic(qf)
}

// ---------------------------------------------------------------------------
// Full Trinity pipeline
// ---------------------------------------------------------------------------
// 1. Private linear layer (polynomial arithmetic — FHE)
// 2. Neural activation (ReLU + bias — AI)
// 3. Quantum commitment (Deutsch oracle — Quantum)
//
// expected_class: the prover's claimed classification.
// Returns: Bool from quantum measurement confirming the commitment.
pub fn trinity(
    input_addr: Field,
    weights_addr: Field,
    bias_addr: Field,
    result_addr: Field,
    activated_addr: Field,
    tmp_addr: Field,
    x: Field,
    n: Field,
    neurons: Field,
    expected_class: Field
) -> Bool {
    private_linear(
        input_addr, weights_addr, result_addr, tmp_addr, x, n, neurons
    )
    activate(result_addr, bias_addr, activated_addr, neurons)
    quantum_commit(expected_class)
}
