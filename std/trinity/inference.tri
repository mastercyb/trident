module std.trinity.inference

// Provable private neural inference with quantum commitment.
//
// Three revolutions, one program:
//   Phase 1 — Privacy: FHE-style linear layer (polynomial arithmetic)
//   Phase 2 — Neural:  ReLU activation + bias
//   Phase 3 — Quantum: Deutsch oracle commitment to classification
//
// The STARK proof covers everything. No other system on earth does this.
use vm.io.mem

use std.nn.tensor

use std.private.poly

use std.quantum.gates

// ---------------------------------------------------------------------------
// Phase 1: Private linear layer via polynomial arithmetic
// ---------------------------------------------------------------------------
// One encrypted neuron: pointwise-mul input with weight polynomial,
// then evaluate at point x to extract the scalar dot product.
// This is exactly how RLWE-based FHE evaluates linear operations:
// encrypted input is a polynomial, plaintext weights are polynomials,
// pointwise multiply in evaluation domain = encrypted dot product.
pub fn private_neuron(
    input_addr: Field,
    weight_addr: Field,
    out_addr: Field,
    x: Field,
    n: Field
) -> Field {
    poly.pointwise_mul(input_addr, weight_addr, out_addr, n)
    poly.eval(out_addr, x, n)
}

// Full private linear layer: 4 neurons, each a polynomial product.
// input_addr:  N coefficients (encrypted input)
// w0..w3_addr: N coefficients each (4 weight polynomials)
// result_addr: 4-element output vector
// tmp_addr:    N-element scratch space
pub fn private_linear(
    input_addr: Field,
    w0_addr: Field,
    w1_addr: Field,
    w2_addr: Field,
    w3_addr: Field,
    result_addr: Field,
    tmp_addr: Field,
    x: Field,
    n: Field
) {
    let r0: Field = private_neuron(input_addr, w0_addr, tmp_addr, x, n)
    mem.write(result_addr, r0)
    let r1: Field = private_neuron(input_addr, w1_addr, tmp_addr, x, n)
    mem.write(result_addr + 1, r1)
    let r2: Field = private_neuron(input_addr, w2_addr, tmp_addr, x, n)
    mem.write(result_addr + 2, r2)
    let r3: Field = private_neuron(input_addr, w3_addr, tmp_addr, x, n)
    mem.write(result_addr + 3, r3)
}

// ---------------------------------------------------------------------------
// Phase 2: Neural activation
// ---------------------------------------------------------------------------
// Standard dense layer post-processing: bias add then ReLU.
// Operates on 4-element vectors in RAM.
pub fn activate(result_addr: Field, bias_addr: Field, out_addr: Field) {
    tensor.bias_add(result_addr, bias_addr, out_addr, 4)
    tensor.relu_layer(out_addr, out_addr, 4)
}

// ---------------------------------------------------------------------------
// Phase 3: Quantum verification commitment
// ---------------------------------------------------------------------------
// Deutsch-style oracle: one quantum query determines the classification.
//
// Circuit: |0> -> H -> (Z if class nonzero) -> H -> measure
//
// When class = 0: HH|0> = |0>, measurement returns true  (|0> wins)
// When class > 0: HZH|0> = X|0> = |1>, measurement returns false (|1> wins)
//
// The prover commits to a specific classification. If the proof verifies,
// the commitment is binding — the computation produced that class.
pub fn quantum_commit(class: Field) -> Bool {
    let q: gates.Qubit = gates.init_zero()
    let q1: gates.Qubit = gates.hadamard(q)
    let mut q2: gates.Qubit = q1
    if class {
        q2 = gates.pauliz(q1)
    }
    let q3: gates.Qubit = gates.hadamard(q2)
    gates.measure_deterministic(q3)
}

// ---------------------------------------------------------------------------
// Full Trinity pipeline
// ---------------------------------------------------------------------------
// 1. Private linear layer (polynomial arithmetic — FHE)
// 2. Neural activation (ReLU + bias — AI)
// 3. Quantum commitment (Deutsch oracle — Quantum)
//
// expected_class: the prover's claimed classification (argmax computed externally).
// Returns: Bool from quantum measurement confirming the commitment.
pub fn trinity(
    input_addr: Field,
    w0_addr: Field,
    w1_addr: Field,
    w2_addr: Field,
    w3_addr: Field,
    bias_addr: Field,
    result_addr: Field,
    activated_addr: Field,
    tmp_addr: Field,
    x: Field,
    n: Field,
    expected_class: Field
) -> Bool {
    private_linear(
        input_addr, w0_addr, w1_addr, w2_addr, w3_addr,
        result_addr, tmp_addr, x, n
    )
    activate(result_addr, bias_addr, activated_addr)
    quantum_commit(expected_class)
}
