module std.trinity.inference

// Provable private neural inference with quantum commitment.
//
// Three revolutions, one program:
//   Phase 1 — Privacy: FHE-style linear layer (polynomial arithmetic)
//   Phase 2 — Neural:  Dense layer (matvec + bias + ReLU)
//   Phase 3 — Quantum: 2-qubit Bell pair commitment circuit
//
// The STARK proof covers everything. No other system on earth does this.
//
// Pitch parameters:
//   8-dim encrypted input, 16-neuron hidden layer, 2-qubit Bell commitment.
//   ~11K dynamic ops, ~3s prove, ~5MB proof.
use vm.core.field

use vm.core.convert

use vm.io.mem

use std.nn.tensor

use std.private.poly

use std.quantum.gates

// ---------------------------------------------------------------------------
// Phase 1: Private linear layer via polynomial arithmetic
// ---------------------------------------------------------------------------
// One encrypted neuron: pointwise-mul input with weight polynomial,
// then evaluate at point x to extract the scalar dot product.
pub fn private_neuron(
    input_addr: Field,
    weight_addr: Field,
    out_addr: Field,
    x: Field,
    n: Field
) -> Field {
    poly.pointwise_mul(input_addr, weight_addr, out_addr, n)
    poly.eval(out_addr, x, n)
}

// Full private linear layer: neurons neurons, each a polynomial product.
// weights laid out contiguously: w[i] starts at weights_addr + i * n.
pub fn private_linear(
    input_addr: Field,
    weights_addr: Field,
    result_addr: Field,
    tmp_addr: Field,
    x: Field,
    n: Field,
    neurons: Field
) {
    for i in 0..neurons bounded 4096 {
        let idx: Field = convert.as_field(i)
        let w_addr: Field = weights_addr + idx * n
        let r: Field = private_neuron(input_addr, w_addr, tmp_addr, x, n)
        mem.write(result_addr + idx, r)
    }
}

// ---------------------------------------------------------------------------
// Phase 2: Neural dense layer
// ---------------------------------------------------------------------------
// Full dense layer: out = relu(W * x + b).
// w_addr: neurons x neurons weight matrix (square, row-major)
// x_addr: neurons-element input (output of Phase 1)
// b_addr: neurons-element bias vector
// out_addr: neurons-element output
// tmp_addr: neurons-element scratch for pre-activation values
pub fn dense_layer(
    w_addr: Field,
    x_addr: Field,
    b_addr: Field,
    out_addr: Field,
    tmp_addr: Field,
    neurons: Field
) {
    tensor.dense(w_addr, x_addr, b_addr, out_addr, tmp_addr, neurons, neurons)
}

// ---------------------------------------------------------------------------
// Phase 3: Quantum commitment (2-qubit Bell pair)
// ---------------------------------------------------------------------------
// Superdense coding commitment circuit:
//   |00> -> H(q0) -> CNOT -> conditional CZ -> CNOT -> H(q0) -> measure q0
//
// The Bell pair encodes entanglement. CZ marks the class into the phase.
// Decode via inverse Bell circuit (CNOT + H), then measure q0.
//
// class=0: |00> -> Bell -> skip CZ -> decode -> |00> -> p0=4,p1=0 -> true
// class>0: |00> -> Bell -> CZ -> decode -> |10> -> p0=0,p1=4 -> false
//
// Two-qubit Hadamard on q0 in computational basis:
//   q00' = q00 + q10,  q01' = q01 + q11
//   q10' = q00 - q10,  q11' = q01 - q11
pub fn quantum_commit(class: Field) -> Bool {
    // Initialize |00>
    let q0: gates.Qubit = gates.init_zero()
    let q1: gates.Qubit = gates.init_zero()
    // Hadamard on q0, then entangle
    let q0h: gates.Qubit = gates.hadamard(q0)
    let bell: gates.TwoQubit = gates.two_qubit_product(q0h, q1)
    let entangled: gates.TwoQubit = gates.cnot(bell)
    // Conditional CZ: negate |11> amplitude if class != 0
    let mut committed: gates.TwoQubit = entangled
    if class {
        committed = gates.cz(entangled)
    }
    // Decode: CNOT then H(q0) on 2-qubit state
    let decoded: gates.TwoQubit = gates.cnot(committed)
    // H on q0: transforms pairs (q0X, q1X) -> (q0X+q1X, q0X-q1X)
    let q00: gates.Complex = gates.complex_add(decoded.q00, decoded.q10)
    let q01: gates.Complex = gates.complex_add(decoded.q01, decoded.q11)
    let q10: gates.Complex = gates.complex_sub(decoded.q00, decoded.q10)
    let q11: gates.Complex = gates.complex_sub(decoded.q01, decoded.q11)
    // Measure q0: trace out q1
    // p0 = |q00|^2 + |q01|^2, p1 = |q10|^2 + |q11|^2
    let p0: Field = gates.complex_norm_sq(q00) + gates.complex_norm_sq(q01)
    let p1: Field = gates.complex_norm_sq(q10) + gates.complex_norm_sq(q11)
    let diff: Field = p0 + field.neg(p1)
    let (hi, lo) = convert.split(diff)
    let threshold: U32 = convert.as_u32(2147483647)
    hi < threshold
}

// ---------------------------------------------------------------------------
// Full Trinity pipeline
// ---------------------------------------------------------------------------
// 1. Private linear layer (polynomial arithmetic — FHE)
// 2. Dense neural layer (matvec + bias + ReLU — AI)
// 3. Quantum commitment (2-qubit Bell circuit — Quantum)
//
// dense_w_addr: neurons x neurons weight matrix for dense layer
// dense_b_addr: neurons-element bias for dense layer
// expected_class: the prover's claimed classification.
// Returns: Bool from quantum measurement confirming the commitment.
pub fn trinity(
    input_addr: Field,
    weights_addr: Field,
    result_addr: Field,
    tmp_addr: Field,
    x: Field,
    n: Field,
    neurons: Field,
    dense_w_addr: Field,
    dense_b_addr: Field,
    activated_addr: Field,
    expected_class: Field
) -> Bool {
    private_linear(
        input_addr, weights_addr, result_addr, tmp_addr, x, n, neurons
    )
    dense_layer(dense_w_addr, result_addr, dense_b_addr, activated_addr, tmp_addr, neurons)
    quantum_commit(expected_class)
}
