program type_native_currency

// Neptune Native Currency Type Script
//
// Validates that native currency (Neptune coins) is conserved across
// a transaction. The type script receives three public inputs:
//   1. kernel MAST hash
//   2. hash of salted input UTXOs
//   3. hash of salted output UTXOs
//
// Conservation law: sum(input amounts) >= sum(output amounts)
// The difference is the implicit fee paid to the miner.
//
// This is the simplest type script — it only checks that the
// total value going in is at least the total value going out.
use ext.neptune.kernel

fn main() {
    // Read the three type-script public inputs.
    let (kernel_hash, input_hash, output_hash) = kernel.read_type_script_hashes()
    // Divine the input and output amounts (prover-supplied).
    // In a real implementation these would be authenticated against
    // input_hash and output_hash via sponge hashing of the full
    // UTXO data. Here we demonstrate the conservation check pattern.
    let num_inputs: Field = divine()
    let num_outputs: Field = divine()
    // Sum input amounts (bounded — max 8 inputs per transaction).
    let mut input_total: Field = 0
    for i in 0..num_inputs bounded 8 {
        let amount: Field = divine()
        let _: U32 = as_u32(amount)
        input_total = input_total + amount
    }
    // Sum output amounts (bounded — max 8 outputs per transaction).
    let mut output_total: Field = 0
    for i in 0..num_outputs bounded 8 {
        let amount: Field = divine()
        let _: U32 = as_u32(amount)
        output_total = output_total + amount
    }
    // Conservation: inputs >= outputs (difference is fee).
    let fee: Field = sub(input_total, output_total)
    let _: U32 = as_u32(fee)
    // Publish the fee for the block producer to verify.
    pub_write(fee)
}
