program lock_timelock

// Neptune Timelock Lock Script
//
// Spendable only after a given timestamp. Combines hash-preimage
// authentication with a time check against the transaction kernel's
// timestamp field.
//
// Public input:  kernel MAST hash (5 fields = 1 Digest)
// Secret input:  lock preimage (5 fields), lock hash (5 fields),
//                unlock_after timestamp (1 field),
//                kernel timestamp leaf (5 fields) + Merkle siblings
use ext.neptune.kernel

fn main() {
    // Authentication: Symmetric-style hash-lock.
    let lock_hash: Digest = divine5()
    let (s0, s1, s2, s3, s4) = divine5()
    let computed: Digest = hash(s0, s1, s2, s3, s4, 0, 0, 0, 0, 0)
    assert_digest(computed, lock_hash)
    // Read kernel MAST hash from public input.
    let kernel_hash: Digest = kernel.read_lock_script_hash()
    // Authenticate the timestamp from the kernel MAST tree.
    // Timestamp is leaf 5 in the 8-leaf kernel tree (depth 3).
    let ts_leaf: Digest = kernel.authenticate_timestamp(kernel_hash)
    let (current_time, _, _, _, _) = ts_leaf
    // The unlock-after timestamp is a program constant.
    // In a real deployment, this is baked in at UTXO creation time.
    let unlock_after: Field = divine()
    // Time check: current_time >= unlock_after
    let diff: Field = sub(current_time, unlock_after)
    let _: U32 = as_u32(diff)
}
