program bitcoin_light_client

// ======================================================================
// Bitcoin SPV Light Client Bridge Validator
//
// Verifies Bitcoin block headers, header chains, Merkle inclusion
// proofs, and proof-of-work difficulty in a ZK circuit.
//
// Trident has no native SHA-256. The prover computes SHA-256
// externally and supplies results via divine(). The circuit verifies
// structural relationships:
//   - Header fields commit to a Tip5 digest (binding)
//   - Chain links: each header's prev_hash matches predecessor
//   - Merkle tree: sibling hashes combine correctly at each level
//   - Difficulty: block hash (U256) < target threshold (U256)
// ======================================================================
use std.crypto.bigint

use std.core.convert

// --- Events ---
event HeaderVerified {
    header_commitment: Digest,
    block_height: Field,
}

event TxInclusionProved {
    tx_commitment: Digest,
    block_commitment: Digest,
}

event ChainVerified {
    start_height: Field,
    end_height: Field,
    anchor_commitment: Digest,
    tip_commitment: Digest,
}

// --- U256 helpers ---
fn divine_u256() -> bigint.U256 {
    let l0: U32 = as_u32(divine())
    let l1: U32 = as_u32(divine())
    let l2: U32 = as_u32(divine())
    let l3: U32 = as_u32(divine())
    let l4: U32 = as_u32(divine())
    let l5: U32 = as_u32(divine())
    let l6: U32 = as_u32(divine())
    let l7: U32 = as_u32(divine())
    bigint.U256 { l0: l0, l1: l1, l2: l2, l3: l3, l4: l4, l5: l5, l6: l6, l7: l7 }
}

fn commit_u256(v: bigint.U256) -> Digest {
    hash(
        convert.as_field(v.l0),
        convert.as_field(v.l1),
        convert.as_field(v.l2),
        convert.as_field(v.l3),
        convert.as_field(v.l4),
        convert.as_field(v.l5),
        convert.as_field(v.l6),
        convert.as_field(v.l7),
        0,
        0
    )
}

// --- Difficulty: block_hash < target (256-bit) ---
fn assert_meets_difficulty(block_hash: bigint.U256, target: bigint.U256) {
    let ok: Bool = bigint.lt256(block_hash, target)
    if ok {
    } else {
        assert_eq(0, 1)
    }
}

// --- Header commitment ---
// Bitcoin header (80 bytes): version, prev_hash (8 U32 limbs),
// merkle_root (8 U32 limbs), timestamp, bits, nonce.
// Split across two Tip5 calls then combined into one digest.
fn commit_header(
    version: Field,
    ph0: Field,
    ph1: Field,
    ph2: Field,
    ph3: Field,
    ph4: Field,
    ph5: Field,
    ph6: Field,
    ph7: Field,
    mr0: Field,
    mr1: Field,
    mr2: Field,
    mr3: Field,
    mr4: Field,
    mr5: Field,
    mr6: Field,
    mr7: Field,
    timestamp: Field,
    bits: Field,
    nonce: Field
) -> Digest {
    let primary: Digest = hash(
        version,
        ph0,
        ph1,
        ph2,
        ph3,
        mr0,
        mr1,
        timestamp,
        bits,
        nonce
    )
    let extended: Digest = hash(
        ph4,
        ph5,
        ph6,
        ph7,
        mr2,
        mr3,
        mr4,
        mr5,
        mr6,
        mr7
    )
    let (p0, p1, p2, p3, p4) = primary
    let (e0, e1, e2, e3, e4) = extended
    hash(p0, p1, p2, p3, p4, e0, e1, e2, e3, e4)
}

// ======================================================================
// Read + Verify a Single Header
// ======================================================================
// Returns (header_commit, block_hash_commit, prev_hash_commit, timestamp)
fn read_and_verify_header(
    block_height: Field
) -> (Digest, Digest, Digest, Field) {
    let version: Field = divine()
    let ph0: Field = divine()
    let ph1: Field = divine()
    let ph2: Field = divine()
    let ph3: Field = divine()
    let ph4: Field = divine()
    let ph5: Field = divine()
    let ph6: Field = divine()
    let ph7: Field = divine()
    let mr0: Field = divine()
    let mr1: Field = divine()
    let mr2: Field = divine()
    let mr3: Field = divine()
    let mr4: Field = divine()
    let mr5: Field = divine()
    let mr6: Field = divine()
    let mr7: Field = divine()
    let timestamp: Field = divine()
    let bits: Field = divine()
    let nonce: Field = divine()
    // Tip5 binding commitment
    let hdr_commit: Digest = commit_header(
        version,
        ph0,
        ph1,
        ph2,
        ph3,
        ph4,
        ph5,
        ph6,
        ph7,
        mr0,
        mr1,
        mr2,
        mr3,
        mr4,
        mr5,
        mr6,
        mr7,
        timestamp,
        bits,
        nonce
    )
    // Prover supplies double-SHA256 block hash and target as U256
    let block_hash: bigint.U256 = divine_u256()
    let bhash_commit: Digest = commit_u256(block_hash)
    let target: bigint.U256 = divine_u256()
    // Bind target to bits for external auditing
    let tc: Digest = commit_u256(target)
    let (t0, t1, t2, t3, t4) = tc
    let _bits_bind: Digest = hash(bits, t0, t1, t2, t3, t4, 0, 0, 0, 0)
    // Proof-of-work
    assert_meets_difficulty(block_hash, target)
    // Range checks
    let _ts: U32 = as_u32(timestamp)
    let _bi: U32 = as_u32(bits)
    let _nc: U32 = as_u32(nonce)
    // prev_hash commitment for chain linking
    let ph_commit: Digest = hash(ph0, ph1, ph2, ph3, ph4, ph5, ph6, ph7, 0, 0)
    emit HeaderVerified { 
        header_commitment: hdr_commit,
        block_height: block_height,
    }
    (hdr_commit, bhash_commit, ph_commit, timestamp)
}

// ======================================================================
// Merkle Inclusion Proof (Bitcoin double-SHA256 tree)
// ======================================================================
fn merkle_combine(current: Digest, sibling: Digest, direction: Field) -> Digest {
    let (c0, c1, c2, c3, c4) = current
    let (s0, s1, s2, s3, s4) = sibling
    if direction == 0 {
        hash(c0, c1, c2, c3, c4, s0, s1, s2, s3, s4)
    } else {
        hash(s0, s1, s2, s3, s4, c0, c1, c2, c3, c4)
    }
}

fn verify_merkle_proof(
    tx_commitment: Digest,
    merkle_root_commitment: Digest,
    proof_depth: Field
) {
    let mut current: Digest = tx_commitment
    for i in 0..proof_depth bounded 32 {
        let sibling: Digest = divine5()
        let direction: Field = divine()
        let dir_check: Field = direction * sub(direction, 1)
        assert_eq(dir_check, 0)
        current = merkle_combine(current, sibling, direction)
    }
    assert_digest(current, merkle_root_commitment)
}

// ======================================================================
// Transaction Inclusion Verification
// ======================================================================
fn verify_tx_inclusion(block_height: Field) {
    let (hdr_commit, _bh, _ph, _ts) = read_and_verify_header(block_height)
    let tx_commitment: Digest = divine5()
    let merkle_root_commitment: Digest = divine5()
    // Bind merkle_root_commitment to header
    let mr_binding: Digest = divine5()
    let (mb0, mb1, mb2, mb3, mb4) = mr_binding
    let (hc0, hc1, hc2, hc3, hc4) = hdr_commit
    let binding_check: Digest = hash(
        hc0,
        hc1,
        hc2,
        hc3,
        hc4,
        mb0,
        mb1,
        mb2,
        mb3,
        mb4
    )
    let binding_expected: Digest = divine5()
    assert_digest(binding_check, binding_expected)
    // Verify Merkle inclusion
    let proof_depth: Field = divine()
    let _dp: U32 = as_u32(proof_depth)
    verify_merkle_proof(tx_commitment, merkle_root_commitment, proof_depth)
    emit TxInclusionProved { 
        tx_commitment: tx_commitment,
        block_commitment: hdr_commit,
    }
}

// ======================================================================
// Header Chain Verification (bounded 16 headers)
// ======================================================================
fn verify_header_chain() {
    let chain_length: Field = pub_read()
    let start_height: Field = pub_read()
    let anchor_commitment: Digest = pub_read5()
    let mut prev_bhash_commit: Digest = anchor_commitment
    let mut prev_timestamp: Field = 0
    let mut last_hdr_commit: Digest = anchor_commitment
    for i in 0..chain_length bounded 16 {
        let current_height: Field = start_height + i
        let (hdr_commit, bhash_commit, ph_commit, timestamp) = read_and_verify_header(
            current_height
        )
        // Chain linking: prev_hash must match predecessor block hash
        let link_witness: Digest = divine5()
        let (lw0, lw1, lw2, lw3, lw4) = link_witness
        let (ph0, ph1, ph2, ph3, ph4) = ph_commit
        let (pb0, pb1, pb2, pb3, pb4) = prev_bhash_commit
        let link_left: Digest = hash(
            ph0,
            ph1,
            ph2,
            ph3,
            ph4,
            lw0,
            lw1,
            lw2,
            lw3,
            lw4
        )
        let link_right: Digest = hash(
            pb0,
            pb1,
            pb2,
            pb3,
            pb4,
            lw0,
            lw1,
            lw2,
            lw3,
            lw4
        )
        let (ll0, ll1, ll2, ll3, ll4) = link_left
        let (lr0, lr1, lr2, lr3, lr4) = link_right
        let combined_link: Digest = hash(
            ll0,
            ll1,
            ll2,
            ll3,
            ll4,
            lr0,
            lr1,
            lr2,
            lr3,
            lr4
        )
        let combined_expected: Digest = divine5()
        assert_digest(combined_link, combined_expected)
        // Timestamp monotonicity
        if i == 0 {
        } else {
            let ts_diff: Field = sub(timestamp, prev_timestamp)
            let _td: U32 = as_u32(ts_diff)
        }
        prev_timestamp = timestamp
        prev_bhash_commit = bhash_commit
        last_hdr_commit = hdr_commit
    }
    let end_height: Field = start_height + chain_length
    emit ChainVerified { 
        start_height: start_height,
        end_height: end_height,
        anchor_commitment: anchor_commitment,
        tip_commitment: last_hdr_commit,
    }
    let (tip0, tip1, tip2, tip3, tip4) = last_hdr_commit
    pub_write(tip0)
    pub_write(tip1)
    pub_write(tip2)
    pub_write(tip3)
    pub_write(tip4)
    pub_write(end_height)
}

// ======================================================================
// Entry Point â€” op=0: single header, op=1: chain, op=2: tx inclusion
// ======================================================================
fn main() {
    let op: Field = pub_read()
    if op == 0 {
        let height: Field = pub_read()
        let (hdr, bhash, _ph, _ts) = read_and_verify_header(height)
        let (h0, h1, h2, h3, h4) = hdr
        pub_write(h0)
        pub_write(h1)
        pub_write(h2)
        pub_write(h3)
        pub_write(h4)
        let (b0, b1, b2, b3, b4) = bhash
        pub_write(b0)
        pub_write(b1)
        pub_write(b2)
        pub_write(b3)
        pub_write(b4)
    } else if op == 1 {
        verify_header_chain()
    } else if op == 2 {
        let height: Field = pub_read()
        verify_tx_inclusion(height)
    } else {
        assert_eq(0, 1)
    }
}
