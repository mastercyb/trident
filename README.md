# Trident

**Write once. Prove anywhere.**

Trident is a programming language for provable computation. Write business
logic once, compile to any blockchain target — zero-knowledge or
conventional. The compiler produces cryptographic proofs that your program
executed correctly, or deploys directly to EVM, SVM, CosmWasm. Same source,
same audit, every chain.

```
program hello

fn main() {
    let a: Field = pub_read()
    let b: Field = pub_read()
    pub_write(a + b)
}
```

```bash
trident build hello.tri --target triton   # → TASM (Triton VM)
trident build hello.tri --target miden    # → MASM (Miden VM)
```

---

## Why Trident

**No compromises.** Every other ZK system trades away at least one of:
quantum safety, privacy, programmability, or permissionless participation.
Trident targets proof systems that satisfy all four.

**Write once, prove anywhere.** The same source compiles to Triton VM,
Miden, and future targets (EVM, WASM, RISC-V). Business logic lives in a
universal core. Platform-specific code is a thin adapter generated by the
compiler.

**The compiler is the theorem prover.** Built-in formal verification:
symbolic execution, algebraic solving, SMT encoding. Annotate with
`#[requires]` and `#[ensures]`, run `trident verify`, get a proof of
correctness for all inputs — or a concrete counterexample. No external
tools. No PhD required.

**Names are metadata. The hash is the identity.** Every function is
content-addressed via Poseidon2 over its normalized AST. Verification
results, compilation artifacts, and audit certificates are portable across
projects, teams, and time. Same code, same hash, forever.

**Cost is not a surprise.** The compiler computes exact proving cost from
source — before execution, before deployment. Not an estimate. An exact
row count per algebraic table.

---

## Architecture

Trident compiles through a tiered intermediate representation:

```
Source (.tri)
    │
    ├── Lexer → Parser → Type Checker
    │
    ├── TIRBuilder → Vec<TIROp>        54 ops, 4 tiers
    │
    └── Lowering (per target)
         ├── TritonLowering  → TASM
         ├── MidenLowering   → MASM
         ├── EvmLowering     → EVM bytecode
         ├── WasmLowering    → WASM
         ├── RiscVLowering   → RISC-V ELF
         └── KIR             → CUDA / Metal / Vulkan
              │
              ▼
         Linker                ← multi-module resolution (all targets)
```

The **TIR** (Trident Intermediate Representation) is a 54-operation,
target-independent IR organized in four tiers:

| Tier | Name | Ops | Compiles to |
|------|------|-----|-------------|
| 0 | Structure | 11 | Every target — control flow, functions, comments |
| 1 | Universal | 32 | Every target — arithmetic, I/O, memory, events, storage |
| 2 | Provable | 6 | Proof-capable targets — sponge, Merkle authentication |
| 3 | Recursion | 5 | Recursive verification — extension field, FRI folding, proof blocks |

A program using only Tier 0-1 ops compiles everywhere. Tier 2 restricts to
ZK targets. Tier 3 restricts to targets with recursive verification. The
compiler enforces this statically.

---

## Quick Start

```bash
cargo build --release            # build from source
trident init my_project          # create a project
cd my_project
trident build main.tri           # compile to assembly
trident check main.tri           # type-check without emitting
trident fmt main.tri             # format source
trident test main.tri            # run #[test] functions
trident verify main.tri          # formal verification
trident doc main.tri             # generate docs with cost annotations
```

---

## Language at a Glance

### Types

| Type | Description |
|------|-------------|
| `Field` | Finite field element (Goldilocks: p = 2^64 - 2^32 + 1) |
| `U32` | Unsigned 32-bit integer (range-checked) |
| `Bool` | Boolean (0 or 1) |
| `Digest` | 5-element hash digest |
| `XField` | Cubic extension field element |
| `[T; N]` | Fixed-size array |
| structs | Named product types |

### Functions and Modules

```
// helpers.tri
module helpers

pub fn double(x: Field) -> Field {
    x + x
}
```

```
// main.tri
program my_app

use helpers

fn main() {
    let x: Field = pub_read()
    pub_write(helpers.double(x))
}
```

### Control Flow

```
if balance > 0 {
    transfer(balance)
} else {
    abort()
}

for i in 0..10 bounded 10 {       // all loops require explicit bounds
    process(i)
}

match op_code {
    0 => { pay() }
    1 => { lock() }
    _ => { reject() }
}
```

### Events

```
event Transfer { from: Digest, to: Digest, amount: Field }

fn pay() {
    reveal Transfer { from: sender, to: receiver, amount: value }
    seal Transfer { from: sender, to: receiver, amount: value }
}
```

`reveal` reveals event fields to the verifier. `seal` hashes them — only the
digest is visible. Same event type, different trust models.

### Formal Verification

```
#[requires(x > 0)]
#[ensures(result > x)]
fn double_positive(x: Field) -> Field {
    x + x
}
```

```bash
trident verify main.tri              # symbolic + algebraic + SMT
trident verify main.tri --z3         # also run Z3
trident equiv main.tri f g           # prove two functions equivalent
```

### Inline Assembly

```
fn custom_op(a: Field, b: Field) -> Field {
    asm(triton, -1) {
        hash
        swap 5 pop 1 swap 4 pop 1
        swap 3 pop 1 swap 2 pop 1
        swap 1 pop 1
    }
}
```

Target-tagged `asm` blocks for when you need direct hardware access.
The effect annotation (`-1`) declares the net stack change.

---

## Standard Library

### Universal (`std/`)

| Module | Purpose |
|--------|---------|
| `std.core.field` | Field arithmetic |
| `std.core.u32` | U32 operations (log2, pow, popcount) |
| `std.core.convert` | Type conversions (as_u32, as_field, split) |
| `std.core.assert` | Assertions (is_true, eq, digest) |
| `std.core.mem` | RAM access (read, write, read_block, write_block) |
| `std.io.io` | Public I/O and witness input |
| `std.crypto.hash` | Cryptographic hashing (Tip5, sponge) |
| `std.crypto.merkle` | Merkle tree authentication |
| `std.crypto.auth` | Authorization (preimage verification) |

### Cryptographic Primitives (`std/crypto/`)

SHA-256, Keccak-256, secp256k1, ed25519, ECDSA, Poseidon, bigint
arithmetic.

### Backend Extensions (`ext/`)

| Module | Purpose |
|--------|---------|
| `ext.neptune.xfield` | Extension field operations |
| `ext.neptune.storage` | Persistent storage |
| `ext.neptune.kernel` | Neptune kernel interface |
| `ext.neptune.utxo` | UTXO verification |

---

## The Endgame

Trident is converging on something unprecedented: a compiler that proves
its own correctness.

The content-addressed registry already stores cryptographic hashes of
every function. Verification certificates are already machine-checkable
proof artifacts. The TIR is a clean, well-defined 54-operation IR with
deterministic lowering to target assembly.

The missing piece: write the lowering logic in Trident itself. Then every
`trident build` produces a proof certificate alongside the assembly — a
cryptographic guarantee that the compilation was faithful. No trusted
compiler binary. No trusted build server. You don't trust — you verify.

Source → TIR → assembly, where each arrow is a proven transformation,
chained into a single certificate: *this assembly correctly implements
this source program.*

Trustless package distribution. Trustless deployment. Math all the way
down.

---

## Documentation

Organized following the [Diataxis](https://diataxis.fr/) framework:

### Tutorials (learning-oriented)

- [Tutorial](docs/tutorials/tutorial.md) — Build your first program step by step
- [For Developers](docs/tutorials/for-developers.md) — Zero-knowledge from scratch
- [For Blockchain Devs](docs/tutorials/for-blockchain-devs.md) — Mental model migration from Solidity/Anchor/CosmWasm

### How-to Guides (task-oriented)

- [Compiling a Program](docs/guides/compiling-a-program.md) — Build, check, cost analysis
- [Running a Program](docs/guides/running-a-program.md) — Execute, test, debug
- [Deploying a Program](docs/guides/deploying-a-program.md) — Neptune scripts, multi-target deployment
- [Generating Proofs](docs/guides/generating-proofs.md) — Execution trace to STARK proof
- [Verifying Proofs](docs/guides/verifying-proofs.md) — Proof checking, on-chain verification
- [Optimization Guide](docs/guides/optimization.md) — Cost reduction strategies

### Reference (information-oriented)

- [Language Reference](docs/reference/reference.md) — Types, operators, builtins, grammar
- [Language Specification](docs/reference/spec.md) — Complete formal specification
- [Error Catalog](docs/reference/errors.md) — Every error message explained
- [IR Design](docs/reference/ir.md) — TIR operations, tiers, lowering

### Explanation (understanding-oriented)

- [Vision](docs/explanation/vision.md) — Why Trident exists
- [Universal Execution](docs/explanation/universal-execution.md) — One source, every chain
- [Programming Model](docs/explanation/programming-model.md) — Execution model and stack semantics
- [How STARK Proofs Work](docs/explanation/stark-proofs.md) — From traces to quantum-safe proofs
- [Formal Verification](docs/explanation/formal-verification.md) — Symbolic execution, SMT, invariant synthesis
- [Content-Addressed Code](docs/explanation/content-addressed.md) — Hashing, caching, registry, equivalence
- [Comparative Analysis](docs/explanation/analysis.md) — Trident vs every other ZK system

---

## Design Principles

1. **Field elements all the way down.** The core numeric type is a finite field element. Everything builds from there.
2. **Bounded execution.** All loops require explicit bounds. No recursion. No halting problem.
3. **Compile-time everything.** All type widths, array sizes, and costs known statically.
4. **Constraints are features.** No heap, no dynamic dispatch, no callbacks — these aren't limitations, they're safety guarantees.
5. **Provable-first, conventional-second.** Designed for ZK. Turns out these constraints make great conventional programs too.
6. **Minimal dependencies.** 4 runtime crates: clap, ariadne, tower-lsp, tokio.

---

## Editor Support

| Editor | Setup |
|--------|-------|
| [Zed](https://zed.dev/) | Extension in `editor/zed/` |
| [Helix](https://helix-editor.com/) | Config in `editor/helix/languages.toml` |
| Any LSP client | `trident lsp` — diagnostics, completions, hover, go-to-definition |

---

## License

[Cyber License](docs/explanation/cyber-license.md): Don't trust. Don't fear. Don't beg.
