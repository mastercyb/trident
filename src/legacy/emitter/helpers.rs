use std::collections::HashMap;

use super::{resolve_type_width, Emitter};
use crate::ast::*;
use crate::span::Spanned;

impl Emitter {
    // --- Stack/output helpers ---

    /// Drain any TASM instructions generated by stack spill/reload operations
    /// and append them to the output.
    pub(super) fn flush_stack_effects(&mut self) {
        for inst in self.stack.drain_side_effects() {
            self.output.push(inst);
        }
    }

    /// Ensure stack space, flush spill effects, emit instruction, push temp to model.
    /// This is the correct ordering: spill BEFORE the physical push instruction.
    pub(super) fn emit_and_push(&mut self, instruction: &str, result_width: u32) {
        if result_width > 0 {
            self.stack.ensure_space(result_width);
            self.flush_stack_effects();
        }
        self.inst(instruction);
        self.stack.push_temp(result_width);
        // push_temp's internal ensure_space is a no-op (space already ensured)
    }

    /// Push an anonymous temporary onto the stack model.
    /// For operations where the physical push already happened (e.g. assertions
    /// that consume a value and produce nothing â€” width 0).
    pub(super) fn push_temp(&mut self, width: u32) {
        self.stack.push_temp(width);
        self.flush_stack_effects();
    }

    /// Find depth of a named variable (may trigger reload if spilled).
    pub(super) fn find_var_depth(&mut self, name: &str) -> u32 {
        let d = self.stack.find_var_depth(name);
        self.flush_stack_effects();
        d
    }

    /// Find depth and width of a named variable (may trigger reload if spilled).
    pub(super) fn find_var_depth_and_width(&mut self, name: &str) -> Option<(u32, u32)> {
        let r = self.stack.find_var_depth_and_width(name);
        self.flush_stack_effects();
        r
    }

    /// Register struct field layout from a type annotation.
    pub(super) fn register_struct_layout_from_type(&mut self, var_name: &str, ty: &Type) {
        if let Type::Named(path) = ty {
            let struct_name = path.0.last().map(|s| s.as_str()).unwrap_or("");
            if let Some(sdef) = self.struct_types.get(struct_name).cloned() {
                let mut field_map = HashMap::new();
                let total: u32 = sdef
                    .fields
                    .iter()
                    .map(|f| resolve_type_width(&f.ty.node, &self.target_config))
                    .sum();
                let mut offset = 0u32;
                for sf in &sdef.fields {
                    let fw = resolve_type_width(&sf.ty.node, &self.target_config);
                    let from_top = total - offset - fw;
                    field_map.insert(sf.name.node.clone(), (from_top, fw));
                    offset += fw;
                }
                self.struct_layouts.insert(var_name.to_string(), field_map);
            }
        }
    }

    /// Look up field offset within a struct variable.
    /// Returns (offset_from_top_of_struct, field_width).
    pub(super) fn find_field_offset_in_var(
        &self,
        var_name: &str,
        field_name: &str,
    ) -> Option<(u32, u32)> {
        if let Some(offsets) = self.struct_layouts.get(var_name) {
            return offsets.get(field_name).copied();
        }
        None
    }

    /// Resolve field offset for Expr::FieldAccess.
    pub(super) fn resolve_field_offset(&self, inner: &Expr, field: &str) -> Option<(u32, u32)> {
        if let Expr::Var(name) = inner {
            return self.find_field_offset_in_var(name, field);
        }
        None
    }

    /// Compute field widths for a struct init.
    pub(super) fn compute_struct_field_widths(
        &self,
        ty: &Option<Spanned<Type>>,
        fields: &[(Spanned<String>, Spanned<Expr>)],
    ) -> Vec<u32> {
        // Try to resolve from struct type definition
        if let Some(sp_ty) = ty {
            if let Type::Named(path) = &sp_ty.node {
                if let Some(name) = path.0.last() {
                    if let Some(sdef) = self.struct_types.get(name) {
                        return sdef
                            .fields
                            .iter()
                            .map(|f| resolve_type_width(&f.ty.node, &self.target_config))
                            .collect();
                    }
                }
            }
        }
        // Fallback: assume each field is width 1
        vec![1u32; fields.len()]
    }

    pub(super) fn emit_pop(&mut self, n: u32) {
        let mut remaining = n;
        while remaining > 0 {
            let batch = remaining.min(5);
            self.b_pop(batch);
            remaining -= batch;
        }
    }
}
