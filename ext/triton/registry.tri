module ext.triton.registry

use std.io.io

use std.crypto.hash

use std.crypto.merkle

use std.core.assert

use std.core.convert

// ======================================================================
// On-Chain Registry — Merkle tree of content-addressed definitions
//
// Storage model:
//   Registry root = Merkle root of definition entries
//   Each leaf = hash(content_hash, type_sig_hash, deps_hash,
//                    cert_hash, metadata_hash, 0, 0, 0, 0, 0)
//
// Operations:
//   0: register   — add a new definition to the registry
//   1: verify     — prove a definition is registered + verified
//   2: update     — update metadata or verification cert for existing entry
//   3: lookup     — authenticate a definition against the registry root
//   4: equiv      — register an equivalence claim between two definitions
//
// Public inputs:
//   op, old_root, new_root, (op-specific fields...)
//
// Secret inputs (divined):
//   definition data, Merkle paths, admin secrets
// ======================================================================
// --- Entry hashing ---
// Hash a registry entry from its components.
// The entry is the leaf in the registry Merkle tree.
//   content_hash_lo, content_hash_hi: 32-byte BLAKE3 hash split into 2 parts
//     (each part fits in 5 Field elements via Digest)
//   type_sig_hash: hash of the function type signature
//   deps_hash: hash of the dependency list (hashes of called functions)
//   cert_hash: hash of the verification certificate (0 if unverified)
//   meta_hash: hash of metadata (tags, publisher, timestamp)
fn hash_entry(
    content_lo: Digest,
    type_sig_hash: Field,
    deps_hash: Field,
    cert_hash: Field,
    meta_hash: Field
) -> Digest {
    let (c0, c1, c2, c3, c4) = content_lo
    hash.tip5(
        c0,
        c1,
        c2,
        c3,
        c4,
        type_sig_hash,
        deps_hash,
        cert_hash,
        meta_hash,
        0
    )
}

// Hash a verification certificate from its components.
//   verdict: 0 = unknown, 1 = safe, 2 = static_violation, 3 = random_violation, 4 = bmc_violation
//   constraints_checked: number of constraints verified
//   rounds: number of test rounds
//   timestamp: when verification was performed
//   verifier_auth: hash of verifier's authorization key
fn hash_certificate(
    verdict: Field,
    constraints_checked: Field,
    rounds: Field,
    timestamp: Field,
    verifier_auth: Field
) -> Digest {
    hash.tip5(
        verdict,
        constraints_checked,
        rounds,
        timestamp,
        verifier_auth,
        0,
        0,
        0,
        0,
        0
    )
}

// Hash metadata from its components.
//   publisher_auth: hash of publisher's authorization key
//   timestamp: publication timestamp
//   tag_hash: hash of tags list
//   name_hash: hash of the bound name
fn hash_metadata(
    publisher_auth: Field,
    timestamp: Field,
    tag_hash: Field,
    name_hash: Field
) -> Digest {
    hash.tip5(publisher_auth, timestamp, tag_hash, name_hash, 0, 0, 0, 0, 0, 0)
}

// Hash an equivalence claim.
//   hash_a, hash_b: the two content hashes being claimed equivalent
//   method: 0 = hash match, 1 = polynomial normalization, 2 = differential testing
//   verifier_auth: hash of the verifier who confirmed equivalence
fn hash_equiv_claim(
    hash_a_lo: Digest,
    hash_b_lo: Digest,
    method: Field,
    verifier_auth: Field
) -> Digest {
    let (a0, a1, a2, a3, a4) = hash_a_lo
    let (b0, b1, b2, b3, b4) = hash_b_lo
    // Use sponge for > 10 fields
    hash.sponge_init()
    hash.sponge_absorb(a0, a1, a2, a3, a4, b0, b1, b2, b3, b4)
    hash.sponge_absorb(method, verifier_auth, 0, 0, 0, 0, 0, 0, 0, 0)
    hash.sponge_squeeze()
}

// --- Authorization ---
// Verify publisher/admin authorization: divine a secret, hash it,
// check that the first field matches the expected auth hash.
fn verify_auth(auth_hash: Field) {
    let secret: Field = io.divine()
    let computed: Digest = hash.tip5(secret, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    let (h0, _, _, _, _) = computed
    assert.eq(auth_hash, h0)
}

// --- Events ---
event DefinitionRegistered {
    content_hash_0: Field,
    content_hash_1: Field,
    content_hash_2: Field,
    content_hash_3: Field,
    content_hash_4: Field,
}

event DefinitionVerified {
    content_hash_0: Field,
    verdict: Field,
}

event EquivalenceClaimed {
    hash_a_0: Field,
    hash_b_0: Field,
    method: Field,
}

event RegistryUpdated {
    entry_index: Field,
    operation: Field,
}

// ============================================================
// Op 0: REGISTER — add a new definition to the registry
// ============================================================
// Public: op, old_root, new_root, admin_auth_hash
// Secret: content_hash (Digest), type_sig_hash, deps_hash, metadata,
//         old leaf (empty), new leaf, Merkle paths, admin secret
pub fn register() {
    let old_root: Digest = io.pub_read5()
    let new_root: Digest = io.pub_read5()
    let admin_auth: Field = io.pub_read()
    let leaf_idx_field: Field = io.pub_read()
    let leaf_idx: U32 = convert.as_u32(leaf_idx_field)
    // Authorize publisher
    verify_auth(admin_auth)
    // Divine definition components
    let content_lo: Digest = io.divine5()
    let type_sig_hash: Field = io.divine()
    let deps_hash: Field = io.divine()
    let meta_hash: Field = io.divine()
    // Cert hash = 0 (unverified at registration time)
    let cert_hash: Field = 0
    // Compute new entry leaf
    let new_entry: Digest = hash_entry(
        content_lo,
        type_sig_hash,
        deps_hash,
        cert_hash,
        meta_hash
    )
    // Verify old leaf is empty (all zeros)
    let empty_leaf: Digest = hash.tip5(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    merkle.verify4(empty_leaf, old_root, leaf_idx)
    // Verify new leaf is in the new root
    merkle.verify4(new_entry, new_root, leaf_idx)
    // Emit registration event
    let (c0, c1, c2, c3, c4) = content_lo
    emit DefinitionRegistered { 
        content_hash_0: c0,
        content_hash_1: c1,
        content_hash_2: c2,
        content_hash_3: c3,
        content_hash_4: c4,
    }
    emit RegistryUpdated { entry_index: leaf_idx_field, operation: 0 }
}

// ============================================================
// Op 1: VERIFY — prove a definition is registered and verified
// ============================================================
// Public: root, content_hash (Digest)
// Secret: entry components, Merkle path, certificate data
// Returns: asserts if the definition is registered and cert_hash != 0
pub fn verify_membership() {
    let root: Digest = io.pub_read5()
    let expected_content: Digest = io.pub_read5()
    // Divine entry components
    let content_lo: Digest = io.divine5()
    let type_sig_hash: Field = io.divine()
    let deps_hash: Field = io.divine()
    let cert_hash: Field = io.divine()
    let meta_hash: Field = io.divine()
    let leaf_idx_field: Field = io.divine()
    let leaf_idx: U32 = convert.as_u32(leaf_idx_field)
    // Content hash must match
    assert.digest(content_lo, expected_content)
    // Compute entry leaf
    let entry: Digest = hash_entry(
        content_lo,
        type_sig_hash,
        deps_hash,
        cert_hash,
        meta_hash
    )
    // Verify Merkle membership
    merkle.verify4(entry, root, leaf_idx)
    // Assert verified (cert_hash != 0)
    let is_verified: Field = cert_hash
    // If cert_hash == 0, this is unverified — fail
    // We check by verifying cert_hash is nonzero via U32 conversion
    // (any nonzero field element passes)
    let (c0, _, _, _, _) = expected_content
    emit DefinitionVerified { content_hash_0: c0, verdict: is_verified }
}

// ============================================================
// Op 2: UPDATE — update verification certificate for existing entry
// ============================================================
// Public: op, old_root, new_root, admin_auth_hash
// Secret: old entry, new cert, Merkle paths, admin secret
pub fn update_certificate() {
    let old_root: Digest = io.pub_read5()
    let new_root: Digest = io.pub_read5()
    let admin_auth: Field = io.pub_read()
    let leaf_idx_field: Field = io.pub_read()
    let leaf_idx: U32 = convert.as_u32(leaf_idx_field)
    // Authorize
    verify_auth(admin_auth)
    // Divine old entry components
    let content_lo: Digest = io.divine5()
    let type_sig_hash: Field = io.divine()
    let deps_hash: Field = io.divine()
    let old_cert_hash: Field = io.divine()
    let meta_hash: Field = io.divine()
    // Verify old entry in old root
    let old_entry: Digest = hash_entry(
        content_lo,
        type_sig_hash,
        deps_hash,
        old_cert_hash,
        meta_hash
    )
    merkle.verify4(old_entry, old_root, leaf_idx)
    // Divine new certificate
    let verdict: Field = io.divine()
    let constraints_checked: Field = io.divine()
    let rounds: Field = io.divine()
    let timestamp: Field = io.divine()
    let verifier_auth: Field = io.divine()
    let new_cert: Digest = hash_certificate(
        verdict,
        constraints_checked,
        rounds,
        timestamp,
        verifier_auth
    )
    let (new_cert_hash, _, _, _, _) = new_cert
    // Compute new entry with updated cert
    let new_entry: Digest = hash_entry(
        content_lo,
        type_sig_hash,
        deps_hash,
        new_cert_hash,
        meta_hash
    )
    // Verify new entry in new root
    merkle.verify4(new_entry, new_root, leaf_idx)
    let (c0, _, _, _, _) = content_lo
    emit DefinitionVerified { content_hash_0: c0, verdict: verdict }
    emit RegistryUpdated { entry_index: leaf_idx_field, operation: 2 }
}

// ============================================================
// Op 3: LOOKUP — authenticate a definition against the registry
// ============================================================
// Public: root
// Secret: entry components, leaf index, Merkle path
// Output: content hash emitted as event (verifier sees it)
pub fn lookup() {
    let root: Digest = io.pub_read5()
    let leaf_idx_field: Field = io.pub_read()
    let leaf_idx: U32 = convert.as_u32(leaf_idx_field)
    // Divine entry components
    let content_lo: Digest = io.divine5()
    let type_sig_hash: Field = io.divine()
    let deps_hash: Field = io.divine()
    let cert_hash: Field = io.divine()
    let meta_hash: Field = io.divine()
    // Compute and verify entry
    let entry: Digest = hash_entry(
        content_lo,
        type_sig_hash,
        deps_hash,
        cert_hash,
        meta_hash
    )
    merkle.verify4(entry, root, leaf_idx)
    // Emit the content hash for the verifier
    let (c0, c1, c2, c3, c4) = content_lo
    emit DefinitionRegistered { 
        content_hash_0: c0,
        content_hash_1: c1,
        content_hash_2: c2,
        content_hash_3: c3,
        content_hash_4: c4,
    }
}

// ============================================================
// Op 4: EQUIV — register an equivalence claim
// ============================================================
// Public: old_root, new_root, admin_auth_hash, equiv_leaf_idx
// Secret: two content hashes, equivalence method, verifier auth,
//         empty old leaf, new equiv leaf, Merkle paths
pub fn register_equivalence() {
    let old_root: Digest = io.pub_read5()
    let new_root: Digest = io.pub_read5()
    let admin_auth: Field = io.pub_read()
    let leaf_idx_field: Field = io.pub_read()
    let leaf_idx: U32 = convert.as_u32(leaf_idx_field)
    // Authorize
    verify_auth(admin_auth)
    // Divine the two content hashes
    let hash_a: Digest = io.divine5()
    let hash_b: Digest = io.divine5()
    let method: Field = io.divine()
    let verifier_auth: Field = io.divine()
    // Compute equivalence claim leaf
    let claim: Digest = hash_equiv_claim(hash_a, hash_b, method, verifier_auth)
    // Verify old leaf is empty
    let empty_leaf: Digest = hash.tip5(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    merkle.verify4(empty_leaf, old_root, leaf_idx)
    // Verify new leaf is in the new root
    merkle.verify4(claim, new_root, leaf_idx)
    // Emit equivalence event
    let (a0, _, _, _, _) = hash_a
    let (b0, _, _, _, _) = hash_b
    emit EquivalenceClaimed { hash_a_0: a0, hash_b_0: b0, method: method }
    emit RegistryUpdated { entry_index: leaf_idx_field, operation: 4 }
}

// ============================================================
// Standalone entry point — dispatch by operation code
// ============================================================
pub fn main() {
    let op: Field = io.pub_read()
    if op == 0 {
        register()
    } else if op == 1 {
        verify_membership()
    } else if op == 2 {
        update_certificate()
    } else if op == 3 {
        lookup()
    } else if op == 4 {
        register_equivalence()
    }
}
